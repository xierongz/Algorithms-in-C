*************************************************************
- 《算法：C语言实现》学习日志
- 作者：谢荣桢
- 版本：V1.0
*************************************************************
<a name="0.0.1"></a>
## [0.0.1](#2.2) (2018/9/27 23:09)：

# 第一部分 基础知识
## <span id="chapter1">第一章 引言</span>
### 1.1 算法
### 1.2 典型问题--连通性
### 1.3 合并-查找算法
&emsp;　快速--查找算法(quick-find algorithm)：
&emsp;　　　初始时，数组中的第i个元素的值为i，0<=i<n。
&emsp;　　　为实现p与q的合并操作，遍历数组，把所有名为p的元素值改为q。

- 性质1.1
&emsp;  **求解N个对象的连通性问题，如果执行M次合并操作，那么快速查找算法至少执行MN条指令**
- 性质1.2
&emsp; **对于M>N，快速合并算法求解N个对象、M个对的连通问题需要执行MN/2条指令。**
- 性质1.3
&emsp; **对于N个对象，加权快速合并算法判定其中的两个对象是否是连通的，之多需要遍历2lgN个指针。**

### 1.4 展望
设计算法的基本步骤：
- **确定完整、明确的问题陈述，包括确定问题固有的基本抽象操作。**
- **仔细设计一个简单算法的简明实现。**
- **通过逐步求精的过程开发改进后的算法实现，经过实验分析、数学分析或者两者共同验证改进算法的效率。**
- **找出数据结构或者算法操作的高级抽象表示，能够使改进版本的设计高效，**
- **可能时尽量保证最坏情况下的性能，但实际数据可用时接受好的性能。**

## <span id="chapter2">第二章 算法分析的原理</span>
算法分析的基本方法：
**1.说明这个过程
2.在某个地方描述所用的数学约定
3.为讨论高级技术问题提供基础
4.当比较算法时，对得出的科学基本结论进行正确评价**

### <span id="2.1>2.1 实现和经验分析</span>
&emsp; 理解算法性能的第一步是进行**经验分析**，即给定解决同一问题的两个算法，运行观察哪个的运行时间更长。

&emsp; 但经验分析面临挑战：

**&emsp; 1.对于某些复杂算法，开发一个正确、完整的算法实现
**
**
&emsp; 2.确定输入数据的特性，以及对进行的实验有直接影响的其他因素。
**
&emsp; 对此有三个基本选择：**实际数据、随机数据**或**伪数据**
&emsp; 　　实际数据测试程序的真正开销；

&emsp; 　　随机数据确保实验测试的是算法，而非测试数据；

&emsp; 　　伪数据确保程序可以处理可能的任何输入。

&emsp; 选择算法时常犯的错误：

**&emsp; 　　1.忽略了算法的性能特征

&emsp; 　　2.过多地关注算法的性能特征**


### <sapn id="2.2">2.2 算法分析</span>

&emsp; 对算法进行数学分析的目的：

**&emsp; 　　比较同一任务的不同算法。

&emsp; 　　预测算法在新环境下的性能。

&emsp; 　　设置算法中的参数值。**

&emsp; 算法分析的步骤：

**&emsp; 　　1.明确算法基于的抽象操作，从而从实现中把分析分离出来。**

&emsp; 　　确定用于分析的最重要的量的方法：

**&emsp; 　　　　(1).对于某些典型运行，利用剖析机制决定程序中最常执行的部分。

&emsp; 　　　　(2).寻找这些量的一个近似估计，确保必要时能够对重要程序进行更完整的分析。**

**&emsp; 　　2.研究数据，为算法的输入建立模型**

&emsp; 　　　　(1).假设输入是随机的，并研究程序的平均情况(average-case)下的性能；

&emsp; 　　　　(2).寻求伪输入，并研究程序的最坏情况(worst-case)下的性能。

<a name="0.0.2"></a>
## [0.0.2](#2.3) (2018/10/31 18:59)

### <sapn id="2.3">2.3 函数的增长</span>

&emsp; 　　大多数算法的主要参数是**N**，它对算法的运行时间影响最大。

&emsp; 　　参数**N**可以是多项式的度、待排序或查找的文件大小、文本字符串中的字符个数，或者是对所考虑的问题的规模的其他抽象度量。

注：当这样的参数多于一个时，通常把其中一个参数表示为另一个参数的函数，或者一次考虑一个参数，把分析规约到一个参数上，从而不失一般性只考虑一个参数。

本书中算法的运行时间一般会与以下某个函数成正比：
**$1$**&emsp;　　大多数程序的大部分指令执行一次，或者至多只执行几次。
&emsp; 　　如果一个程序的所有指令具有这个性质，称程序的运行时间为常量。

**$logN$**&emsp;当程序的运行时间为对数时，程序随着N的增长稍微变慢。　

&emsp; 　　当N加倍时，log N只增加常量，只有N增加到N^2时，log N才会加倍。

**$N$**&emsp;　当程序的运行时间为线性时，通常对每个输入元素只作了少量处理工作。
&emsp; 　　这种情况对于一个必须处理N个输入(或者产生N个输出)的算法是最优的。

**$NlogN$**&emsp;当把问题分解成小的子问题，且独立求解子问题，然后把这些子问题的解组合成原问题的解时，就会出现Nlog N的运行时间。

**$N^2$** &emsp;　当算法的运行时间为二次(quadratic)时，算法只适用于规模较小的问题。
&emsp; 　　二次运行时间一般出现在需要处理所有数据项对(也许是双层嵌套循环)的算法中。

**$N^3$**&emsp;　处理三个数据项的算法(或许是三层嵌套循环)的运行时间为立方(cubic)，算法只适用于小规模问题。

**$2^N$**&emsp;　一个指数(exponential)运行时间的算法与蛮力方法求解问题一样。

程序的运行时间很可能是某个项(首项)的常量倍，再加上某些低阶项。

- 常系数的值和包含的项数取决于分析的结果和实现的细节：
    1.首项的系数与内层循环中的指令数有关：在算法设计的任一层上，要仔细限制这样指令的数目。
    2.为了降低程序的总运行时间，把注意力放在使内层循环中的指令数最少上。

<a name="0.0.3"></a>
## [0.0.3](#2.6) (2018-11-04 19:03)

### <sapn id="2.4">2.4 大O符号</span>

<font size = 5>**定义2.1:**</font> **如果存在常数$c_{0}$和$N_{0}$，对于所有$N > N_{0}$,有$g(N) < c_{0}f(N)$，则称函数$g(N)$是$O(f(N))$的。**
**大O符号的作用：**

    - 限制忽略数学公式中的低阶项时产生的误差。
    - 限制由于忽略对程序的总运行时间贡献较小的某些部分时产生的错误。
    - 允许我们按照算法的总运行时间的上界对算法进行分类。

含有大O项的公式称为 **渐进表达式**。

### <sapn id="2.5">2.5 基本递归方程</span>

<font size = 5>**公式2.1:**</font>  **如果程序的循环通过输入每次减少一项，递归公式为：**
$$C_{N} = C_{N-1} + N, N \geq 2, 且C_{1} = 1$$

<font size = 5>**公式2.2:**</font>  **如果程序每次使输入减半，递归公式为：**
$$C_{N} = C_{N/2} + 1, N \geq 2, 且C_{1} = 1$$

<font size = 5>**公式2.3:**</font>  **如果程序每次使输入减半，但需要检查输入的每一项，递归公式为：**
$$C_{N} = C_{N/2} + N, N \geq 2, 且C_{1} = 0$$

<font size = 5>**公式2.4:**</font>  **如果程序每次把输入分成两半，但在划分前以及划分之后需要线性遍历输入，递归公式为：**
$$C_{N} = 2C_{N/2} + N, N \geq 2, 且C_{1} = 0$$

注：这个公式最常用。

<font size = 5>**公式2.5:**</font>  **如果程序把输入分成两半，然后做一些需要常量时间的其他工作[(见第五章)](#chapter5)，递归公式为：**
$$C_{N} = 2C_{N/2} + 1, N \geq 2, 且C_{1} = 1$$

### <span id="2.6">2.6 算法分析示例<span>

&emsp;　考虑两个基本的搜索算法：**顺序搜索(sequential search)** 和 **二分搜索(binary search)**

1. [程序2.1](例题/chapter2/example2.1.c)实现了搜索问题的直接求解过程。
    把所有对象存储在数组中，然后，对于每次事务，只要从头到尾顺序遍历整个数组，并检查每个元素，看是否是我们要查找的对象。

2. [程序2.2](例题/chapter2/example2.2.c)是搜索问题的一种经典解法，它要比顺序搜索更高效。
    如果表中的数是有序的，通过把待查找的数与表的中间位置的数进行比较，可以去掉表中一半的数：如果比较结果相等，查找成功；如果比中间位置的元素小，则在表的左边应用相同的方法；如果比中间位置的元素大，则在表的右边应用相同的方法。

<font size = 5>**性质2.1:**</font> **顺序搜索对于每次不成功的搜索需要检查$N$个数，对成功搜索平均检查约$N/2$个数**

<font size = 5>**性质2.2:**</font> **在有序表中进行顺序搜索最坏情况下每次搜索需要检查$N$个数，平均情况下每个搜索需要检查大约$N/2$个数。**

<font size = 5>**性质2.3:**</font> **二分搜索至多检查$[lgN]+1$个数。**
